# Uniswap V3 Decoder Analysis

## 1. IDENTIFY_CONTRACTS

**NFT Position Manager (all chains):**
- `0xC36442b4a4522E871399CD717aBDD847Ab11FE88` (Ethereum, Polygon, Arbitrum, Optimism)
- `0x03a520b32C04BF3bEEf7BEb72E919cf822Ed34f1` (Base)
- `0x7b8A01B39D58278b5DE7e48c8449c9f4F5170613` (Binance Smart Chain)
- Purpose: Manages LP positions as NFTs

**Router Addresses:**
- `0xE592427A0AEce92De3Edee1F18E0157C05861564` (Auto Router V1)
- `0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45` (Auto Router V2)
- `0x3fC91A3afd70395Cd496C647d5a6CC9D4B2b7FAD` (Universal Router V1)
- `0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B` (Universal Router V2)
- Purpose: Execute swaps with optimal routing

---

## 2. EXTRACT_SIGNATURES

### SWAP Operation
```
OPERATION: Swap
SIGNATURE: b'\xc4 y\xf9JcP\xd7\xe6#_)\x17I$\xf9(\xcc*\xc8\x18\xebd\xfe\xd8\x00N\x11_\xbc\xcag'
RECOGNITION: Any pool contract emitting Swap event with this topic[0]
```

### INCREASE_LIQUIDITY Operation
```
OPERATION: Deposit/Add Liquidity
SIGNATURE: b'0g\x04\x8b\xee\xe3\x1b%\xb2\xf1h\x1f\x88\xda\xc88\xc8\xbb\xa3j\xf2[\xfb+|\xf7G:XG\xe3_'
RECOGNITION: NFT Manager contract emitting IncreaseLiquidity event
```

### COLLECT_LIQUIDITY Operation
```
OPERATION: Withdraw/Remove Liquidity
SIGNATURE: b"@\xd0\xef\xd1\xa5=`\xec\xbf@\x97\x1b\x9d\xaf}\xc9\x01x\xc3\xaa\xdcz\xab\x17ec'8\xfa\x8b\x8f\x01"
RECOGNITION: NFT Manager contract emitting Collect event
```

---

## 3. DECODE_STEPS

### OPERATION: Basic Swap Detection

**STEPS:**
1. **Check:** Log topic[0] == SWAP_SIGNATURE
2. **Extract:** 
   - `delta_token_0` = signed int from `data[0:32]`
   - `delta_token_1` = signed int from `data[32:64]`
3. **Resolve:**
   - Determine amounts: if delta_token_0 > 0, amounts are (delta_token_0, -delta_token_1), else (delta_token_1, -delta_token_0)
   - Returns (amount_received, amount_sent) = (amounts[1], amounts[0])
4. **Create:**
   - Find last 3 events in decoded_events (checking for spend, approval, receive)
   - Label matching SPEND event → HistoryEventType.TRADE, HistoryEventSubType.SPEND
   - Label matching RECEIVE event → HistoryEventType.TRADE, HistoryEventSubType.RECEIVE
   - Set counterparty = CPT_UNISWAP_V3
5. **Special:** 
   - Skips native currency events (handled by router decoder)
   - Stops at previous swap events (they're already decoded)
   - Returns DecodingOutput with process_swaps=True

---

### OPERATION: Router Swap (Native → Token)

**STEPS:**
1. **Check:** 
   - transaction.to_address in UNISWAP_ROUTER_ADDRESSES
   - Find SPEND event with native currency
   - Optional: RECEIVE event with native currency (refund)
2. **Extract:**
   - from_amount = send_native_event.amount - (receive_native_event.amount if refund else 0)
3. **Resolve:**
   - Call `_find_to_asset_and_amount()` to sum all TRADE/RECEIVE events with CPT_UNISWAP_V3
   - to_asset and to_amount from found events
4. **Create:**
   - Single SPEND event (sequence_index=1): from_asset=native, from_amount
   - Single RECEIVE event (sequence_index=2): to_asset, to_amount
   - Both with HistoryEventType.TRADE, counterparty=CPT_UNISWAP_V3
5. **Special:**
   - Consolidates multiple intermediate swap events into single in/out events
   - Gas event forced to sequence_index=0

---

### OPERATION: Router Swap (Token → Native)

**STEPS:**
1. **Check:**
   - transaction.to_address in UNISWAP_ROUTER_ADDRESSES
   - Find RECEIVE event with native currency
2. **Extract:**
   - to_amount = receive_native_event.amount
3. **Resolve:**
   - Call `_find_from_asset_and_amount()` to sum all TRADE/SPEND events with CPT_UNISWAP_V2/V3
   - from_asset and from_amount from found events
4. **Create:**
   - Single SPEND event: from_asset, from_amount
   - Single RECEIVE event: to_asset=native, to_amount
   - Both with HistoryEventType.TRADE, counterparty=CPT_UNISWAP_V3
5. **Special:** Same consolidation as native→token swap

---

### OPERATION: Router Swap (Token → Token)

**STEPS:**
1. **Check:**
   - transaction.to_address in UNISWAP_ROUTER_ADDRESSES
   - No native currency events (except gas)
2. **Extract:** None needed
3. **Resolve:**
   - Call `_find_from_asset_and_amount()` for from_data
   - Call `_find_to_asset_and_amount()` for to_data
4. **Create:**
   - Single SPEND event: from_asset, from_amount
   - Single RECEIVE event: to_asset, to_amount
   - Both with HistoryEventType.TRADE, counterparty=CPT_UNISWAP_V3
5. **Special:** Same consolidation pattern

---

### OPERATION: Add Liquidity (Deposit)

**STEPS:**
1. **Check:** 
   - Log address == NFT_MANAGER
   - Log topic[0] == INCREASE_LIQUIDITY_SIGNATURE
2. **Extract:**
   - position_id = int from topics[1]
   - amount0_raw = int from data[32:64]
   - amount1_raw = int from data[64:96]
3. **Resolve:**
   - Query NFT Manager contract `positions(position_id)` to get:
     - token0 address (result[2])
     - token1 address (result[3])
   - Call `get_or_create_evm_token()` for both tokens
   - Normalize amounts using `asset_normalized_value()`
4. **Create:**
   - For each matching SPEND/RECEIVE event:
     - HistoryEventType.DEPOSIT
     - HistoryEventSubType.DEPOSIT_ASSET
     - notes = "Deposit {amount} {asset} to Uniswap V3 LP {position_id}"
     - counterparty = CPT_UNISWAP_V3
   - If events not found, create ActionItems to transform them
5. **Special:**
   - Handles native currency refunds (removes refund event)
   - Can use ActionItems if events not yet in decoded_events
   - Supports wrapped native currency substitution

---

### OPERATION: Remove Liquidity (Withdrawal)

**STEPS:**
1. **Check:**
   - Log address == NFT_MANAGER
   - Log topic[0] == COLLECT_LIQUIDITY_SIGNATURE
2. **Extract:**
   - position_id = int from topics[1]
   - amount0_raw = int from data[32:64]
   - amount1_raw = int from data[64:96]
3. **Resolve:** Same as Add Liquidity (query positions contract)
4. **Create:**
   - For each matching RECEIVE event:
     - HistoryEventType.WITHDRAWAL
     - HistoryEventSubType.REMOVE_ASSET
     - notes = "Remove {amount} {asset} from Uniswap V3 LP {position_id}"
     - counterparty = CPT_UNISWAP_V3
5. **Special:** Same refund/ActionItem handling as deposits

---

### OPERATION: Create LP Position (NFT Mint)

**STEPS:**
1. **Check:**
   - RECEIVE event with:
     - amount = 1
     - address = ZERO_ADDRESS
     - event_subtype = NONE
     - asset is ERC721 from NFT_MANAGER with position_id
2. **Extract:**
   - position_id from asset identifier
3. **Resolve:**
   - Update token in database with protocol, name, symbol
4. **Create:**
   - HistoryEventType.RECEIVE
   - HistoryEventSubType.RECEIVE_WRAPPED
   - notes = "Create Uniswap V3 LP with id {position_id}"
   - counterparty = CPT_UNISWAP_V3
5. **Special:**
   - Changes DEPOSIT_ASSET → DEPOSIT_FOR_WRAPPED for associated deposit events
   - Reshuffles events for proper ordering

---

### OPERATION: Exit LP Position (NFT Burn)

**STEPS:**
1. **Check:**
   - SPEND event with:
     - amount = 1
     - address = ZERO_ADDRESS
     - event_subtype = NONE
     - asset is ERC721 from NFT_MANAGER with position_id
2. **Extract:**
   - position_id from asset identifier
3. **Resolve:** None needed
4. **Create:**
   - HistoryEventType.SPEND
   - HistoryEventSubType.RETURN_WRAPPED
   - notes = "Exit Uniswap V3 LP with id {position_id}"
   - counterparty = CPT_UNISWAP_V3
5. **Special:**
   - Changes REMOVE_ASSET → REDEEM_WRAPPED for associated withdrawal events
   - Reshuffles events for proper ordering